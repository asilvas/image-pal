{"version":3,"file":"image-pal-rgb.js","sources":["webpack:///webpack/bootstrap 1849d9b327bb57c82025","webpack:///lib/shared/get-options.js","webpack:///lib/shared/get-colors.js","webpack:///webpack/rgb.js","webpack:///lib/rgb.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1849d9b327bb57c82025","module.exports = ({ hasAlpha, maxColors, minDensity, maxDensity, cubicCells, ...otherOptions } = {}) => {\r\n  if (typeof hasAlpha !== 'boolean') throw new Error('options.hasAlpha is required');\r\n  \r\n  const options = {\r\n    hasAlpha,\r\n    maxColors: Math.min(Math.max(1, maxColors), 20) || 10,\r\n    minDensity: Math.min(Math.max(0.001, minDensity), 1) || 0.005,\r\n    //maxDensity: maxDensity === false ? false : (Math.min(Math.max(0.001, maxDensity), 1) || false),\r\n    cubicCells: Math.min(Math.max(3, cubicCells), 4) || 4,\r\n    ...otherOptions // forward\r\n  };\r\n\r\n  return options;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// lib/shared/get-options.js","module.exports = (imageData, { hasAlpha, maxColors, minDensity, maxDensity, cubicCells, colorPlacer }) => {\r\n  // pre-allocate cells3d[x][y][z]\r\n  // pre-allocate cells[i]\r\n  let x, y, z, i, cell;\r\n  const cells3d = new Array(cubicCells);\r\n  let cells = new Array(Math.pow(cubicCells, 3));\r\n  for (x = 0, i = 0; x < cubicCells; x++) {\r\n    cells3d[x] = new Array(cubicCells);\r\n    for (y = 0; y < cubicCells; y++) {\r\n      cells3d[x][y] = new Array(cubicCells);\r\n      for (z = 0; z < cubicCells; z++, i++) {\r\n        cells3d[x][y][z] = cells[i] = [];\r\n      }\r\n    }\r\n  }\r\n\r\n  const bytesPerPixel = hasAlpha ? 4 : 3;\r\n\r\n  // color placement\r\n  let byte, color;\r\n  const pixels = Math.floor(imageData.length / bytesPerPixel);\r\n  for (i = 0; i < pixels; i++) {\r\n    byte = i * bytesPerPixel;\r\n    color = {\r\n      rgb: [ imageData[byte], imageData[byte + 1], imageData[byte + 2] ],\r\n      alpha: hasAlpha ? imageData[byte + 3] : 255\r\n    };\r\n\r\n    const cellInfo = findCell(colorPlacer(color), cubicCells);\r\n    cells3d[cellInfo.x][cellInfo.y][cellInfo.z].push(color);\r\n  }\r\n\r\n  // sort cells\r\n  cells.sort((a, b) => a.length > b.length ? -1 : a.length < b.length ? 1 : 0);\r\n\r\n  // compute cell densities\r\n  let cellDensities = cells.map(colors => {\r\n    return {\r\n      density: (colors.length / pixels),\r\n      colors\r\n    };\r\n  });\r\n\r\n  // remove cells that don't meet min criteria\r\n  cellDensities = cellDensities.filter(cellData => cellData.density >= minDensity);\r\n\r\n  /* support for maxDensity is disabled for now -- not working as intended. might need a per-colour-space filter option\r\n  if (maxDensity && cellDensities.length > 1 && cellDensities[0].density >= maxDensity) {\r\n    // only filter if:\r\n    // 1. maxDensity is enabled\r\n    // 2. More than one cell exists\r\n    // 3. Meets the maxDensity requirement\r\n    // 4. Never filter more than the first matching cell\r\n    cellDensities = cellDensities.slice(1); // remove first\r\n  }\r\n  */\r\n\r\n  // adhere to maxColors\r\n  if (cellDensities.length > maxColors) {\r\n    cellDensities = cellDensities.slice(0, maxColors); \r\n  }\r\n\r\n  // with remaining cells that match critera, extract median colors\r\n  const medianColors = cellDensities.map(cellData => {\r\n    const colorIdx = Math.floor(cellData.colors.length / 2);\r\n    const medianColor = cellData.colors[colorIdx];\r\n\r\n    // attach hex colors for final palette\r\n    medianColor.hex = rgbToHex(medianColor.rgb[0], medianColor.rgb[1], medianColor.rgb[2]);\r\n    medianColor.density = cellData.density;\r\n\r\n    return medianColor;\r\n  });\r\n\r\n  return medianColors;\r\n};\r\n\r\nfunction findCell(placement, cubicCells) {\r\n  return {\r\n    x: Math.max(0, Math.ceil(Math.min(placement.x, 1) * cubicCells) - 1),\r\n    y: Math.max(0, Math.ceil(Math.min(placement.y, 1) * cubicCells) - 1),\r\n    z: Math.max(0, Math.ceil(Math.min(placement.z, 1) * cubicCells) - 1)\r\n  };\r\n}\r\n\r\nfunction componentToHex(c) {\r\n  const hex = c.toString(16);\r\n  return hex.length === 1 ? \"0\" + hex : hex;\r\n}\r\n\r\nfunction rgbToHex(r, g, b) {\r\n  return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// lib/shared/get-colors.js","import imagePal from '../lib/rgb';\r\n\r\nwindow.imagePalRgb = imagePal;\r\n\n\n\n// WEBPACK FOOTER //\n// webpack/rgb.js","const getOptions = require('./shared/get-options');\r\nconst getColors = require('./shared/get-colors');\r\n\r\nmodule.exports = (imageData, { colorPlacer, ...options }) => {\r\n  const opts = {\r\n    colorPlacer: colorPlacer || rgbColorPlacer,\r\n    ...getOptions(options)\r\n  };\r\n  return getColors(imageData, opts);\r\n};\r\n\r\nfunction rgbColorPlacer(c) {\r\n  return {\r\n    x: c.rgb[0] / 256,\r\n    y: c.rgb[1] / 256,\r\n    z: c.rgb[2] / 256\r\n  };\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// lib/rgb.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;AC7DA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAQA;AACA;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5FA;AACA;;;;;AACA;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;;A","sourceRoot":""}