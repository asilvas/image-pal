{"version":3,"file":"image-pal-hsluv.js","sources":["webpack:///webpack/bootstrap 73513e219af3016a0832","webpack:///lib/shared/get-options.js","webpack:///lib/shared/get-colors.js","webpack:///webpack/hsluv.js","webpack:///lib/hsluv.js","webpack:///./node_modules/hsluv/hsluv.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 73513e219af3016a0832","module.exports = ({ hasAlpha, maxColors, minDensity, /*maxDensity,*/ cubicCells, mean, order, ...otherOptions } = {}) => {\n  if (typeof hasAlpha !== 'boolean') throw new Error('options.hasAlpha is required');\n  \n  const options = {\n    hasAlpha,\n    maxColors: Math.min(Math.max(1, maxColors), 32) || 10,\n    minDensity: Math.min(Math.max(0.001, minDensity), 1) || 0.005,\n    //maxDensity: maxDensity === false ? false : (Math.min(Math.max(0.001, maxDensity), 1) || false),\n    cubicCells: Math.min(Math.max(3, cubicCells), 4) || 4,\n    mean: mean === false ? false : true,\n    order: order === 'density' ? order : 'distance',\n    ...otherOptions // forward\n  };\n\n  return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// lib/shared/get-options.js","module.exports = (imageData, { hasAlpha, maxColors, minDensity, /*maxDensity,*/ cubicCells, mean, order, applyColor, colorPlacer }) => {\n  // pre-allocate cells3d[x][y][z]\n  // pre-allocate cells[i]\n  let x, y, z, i, cell;\n  const cells3d = new Array(cubicCells);\n  let cells = new Array(Math.pow(cubicCells, 3));\n  for (x = 0, i = 0; x < cubicCells; x++) {\n    cells3d[x] = new Array(cubicCells);\n    for (y = 0; y < cubicCells; y++) {\n      cells3d[x][y] = new Array(cubicCells);\n      for (z = 0; z < cubicCells; z++, i++) {\n        cells3d[x][y][z] = cells[i] = [];\n      }\n    }\n  }\n\n  const bytesPerPixel = hasAlpha ? 4 : 3;\n\n  // color placement\n  let byte, color;\n  const pixels = Math.floor(imageData.length / bytesPerPixel);\n  for (byte = 0, i = 0; i < pixels; byte += bytesPerPixel, i++) {\n    color = {\n      rgb: [ imageData[byte], imageData[byte + 1], imageData[byte + 2] ],\n      alpha: hasAlpha ? imageData[byte + 3] : 255\n    };\n\n    if (applyColor) applyColor(color); // apply any color logic, if any\n    color.xyz = colorPlacer(color);\n    const xyz = findCell(color.xyz, cubicCells);\n    cells3d[xyz[0]][xyz[1]][xyz[2]].push(color);\n  }\n\n  // sort cells\n  cells.sort((a, b) => a.length > b.length ? -1 : a.length < b.length ? 1 : 0);\n\n  // compute cell densities\n  let cellDensities = cells.map(colors => {\n    return {\n      density: (colors.length / pixels),\n      colors\n    };\n  });\n\n  // remove cells that don't meet min criteria\n  cellDensities = cellDensities.filter(cellData => cellData.density >= minDensity);\n\n  /* support for maxDensity is disabled for now -- not working as intended. might need a per-colour-space filter option\n  if (maxDensity && cellDensities.length > 1 && cellDensities[0].density >= maxDensity) {\n    // only filter if:\n    // 1. maxDensity is enabled\n    // 2. More than one cell exists\n    // 3. Meets the maxDensity requirement\n    // 4. Never filter more than the first matching cell\n    cellDensities = cellDensities.slice(1); // remove first\n  }*/\n\n  // adhere to maxColors\n  if (cellDensities.length > maxColors) {\n    cellDensities = cellDensities.slice(0, maxColors); \n  }\n\n  // with remaining cells that match critera, extract mean or median colors\n  let palette = cellDensities.map(cellData => {\n    if (mean) { // apply mean calculations\n      const sumRgb = cellData.colors.reduce((state, c) => {\n        state.r += c.rgb[0];\n        state.g += c.rgb[1];\n        state.b += c.rgb[2];\n        return state;\n      }, { r: 0, g: 0, b: 0 });\n      const len = cellData.colors.length;\n      color = {\n        rgb: [\n          Math.min(255, Math.round(sumRgb.r / len)),\n          Math.min(255, Math.round(sumRgb.g / len)),\n          Math.min(255, Math.round(sumRgb.b / len))\n        ],\n        alpha: cellData.colors[0].alpha // dumb alpha copy\n      };\n      if (applyColor) applyColor(color); // update if color applicator provided\n      color.xyz = colorPlacer(color); // re-calc placement in 3d space\n    } else { // grab median color\n      color = cellData.colors[Math.floor(cellData.colors.length / 2)];\n    }\n\n    // attach hex colors for final palette\n    color.hex = rgbToHex(color.rgb[0], color.rgb[1], color.rgb[2]);\n    color.density = cellData.density;\n    color.distance = (color.xyz[0] + color.xyz[1] + color.xyz[2]) / 3;\n    \n    return color;\n  });\n  \n  if (order === 'distance') { // sort by distance\n    palette = palette.sort((a, b) => a.distance > b.distance ? -1 : a.distance < b.distance ? 1 : 0);\n  } // else, already sorted by density\n\n  return palette;\n};\n\nfunction findCell(xyz, cubicCells) {\n  return [\n    Math.max(0, Math.ceil(Math.min(xyz[0], 1) * cubicCells) - 1),\n    Math.max(0, Math.ceil(Math.min(xyz[1], 1) * cubicCells) - 1),\n    Math.max(0, Math.ceil(Math.min(xyz[2], 1) * cubicCells) - 1)\n  ];\n}\n\nfunction componentToHex(c) {\n  const hex = c.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\nfunction rgbToHex(r, g, b) {\n  return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\n\n\n\n// WEBPACK FOOTER //\n// lib/shared/get-colors.js","import imagePal from '../lib/hsluv';\r\n\r\nwindow.imagePalHsluv = imagePal;\r\n\n\n\n// WEBPACK FOOTER //\n// webpack/hsluv.js","const getOptions = require('./shared/get-options');\r\nconst getColors = require('./shared/get-colors');\r\nconst { rgbToHsluv } = require('hsluv');\r\n\r\nmodule.exports = (imageData, { applyColor, colorPlacer, ...options }) => {\r\n  const opts = {\r\n    applyColor: applyColor || hsluvColor,\r\n    colorPlacer: colorPlacer || hsluvColorPlacer,\r\n    ...getOptions(options)\r\n  };\r\n  return getColors(imageData, opts);\r\n};\r\n\r\nfunction hsluvColor(c) {\r\n  c.hsluv = rgbToHsluv([ c.rgb[0] / 256, c.rgb[1] / 256, c.rgb[2] / 256 ]);\r\n}\r\n\r\nfunction hsluvColorPlacer(c) {\r\n  const tooLightOrDark = c.hsluv[2] < 3 || c.hsluv[2] > 97;\r\n  return [\r\n    tooLightOrDark ? 0 : c.hsluv[0] / 360,\r\n    tooLightOrDark ? 0 : c.hsluv[1] / 100,\r\n    c.hsluv[2] / 100\r\n  ];\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// lib/hsluv.js","(function() {\nvar HxOverrides = function() { };\nHxOverrides.cca = function(s,index) {\n\tvar x = s.charCodeAt(index);\n\tif(x != x) return undefined;\n\treturn x;\n};\nHxOverrides.substr = function(s,pos,len) {\n\tif(pos != null && pos != 0 && len != null && len < 0) return \"\";\n\tif(len == null) len = s.length;\n\tif(pos < 0) {\n\t\tpos = s.length + pos;\n\t\tif(pos < 0) pos = 0;\n\t} else if(len < 0) len = s.length + len - pos;\n\treturn s.substr(pos,len);\n};\nvar Std = function() { };\nStd.parseInt = function(x) {\n\tvar v = parseInt(x,10);\n\tif(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) v = parseInt(x);\n\tif(isNaN(v)) return null;\n\treturn v;\n};\nvar StringTools = function() { };\nStringTools.hex = function(n,digits) {\n\tvar s = \"\";\n\tvar hexChars = \"0123456789ABCDEF\";\n\tdo {\n\t\ts = hexChars.charAt(n & 15) + s;\n\t\tn >>>= 4;\n\t} while(n > 0);\n\tif(digits != null) while(s.length < digits) s = \"0\" + s;\n\treturn s;\n};\nvar hsluv = hsluv || {};\nhsluv.Geometry = function() { };\nhsluv.Geometry.intersectLineLine = function(a,b) {\n\tvar x = (a.intercept - b.intercept) / (b.slope - a.slope);\n\tvar y = a.slope * x + a.intercept;\n\treturn { x : x, y : y};\n};\nhsluv.Geometry.distanceFromOrigin = function(point) {\n\treturn Math.sqrt(Math.pow(point.x,2) + Math.pow(point.y,2));\n};\nhsluv.Geometry.distanceLineFromOrigin = function(line) {\n\treturn Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope,2) + 1);\n};\nhsluv.Geometry.perpendicularThroughPoint = function(line,point) {\n\tvar slope = -1 / line.slope;\n\tvar intercept = point.y - slope * point.x;\n\treturn { slope : slope, intercept : intercept};\n};\nhsluv.Geometry.angleFromOrigin = function(point) {\n\treturn Math.atan2(point.y,point.x);\n};\nhsluv.Geometry.normalizeAngle = function(angle) {\n\tvar m = 2 * Math.PI;\n\treturn (angle % m + m) % m;\n};\nhsluv.Geometry.lengthOfRayUntilIntersect = function(theta,line) {\n\treturn line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));\n};\nhsluv.Hsluv = function() { };\nhsluv.Hsluv.getBounds = function(L) {\n\tvar result = [];\n\tvar sub1 = Math.pow(L + 16,3) / 1560896;\n\tvar sub2;\n\tif(sub1 > hsluv.Hsluv.epsilon) sub2 = sub1; else sub2 = L / hsluv.Hsluv.kappa;\n\tvar _g = 0;\n\twhile(_g < 3) {\n\t\tvar c = _g++;\n\t\tvar m1 = hsluv.Hsluv.m[c][0];\n\t\tvar m2 = hsluv.Hsluv.m[c][1];\n\t\tvar m3 = hsluv.Hsluv.m[c][2];\n\t\tvar _g1 = 0;\n\t\twhile(_g1 < 2) {\n\t\t\tvar t = _g1++;\n\t\t\tvar top1 = (284517 * m1 - 94839 * m3) * sub2;\n\t\t\tvar top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;\n\t\t\tvar bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;\n\t\t\tresult.push({ slope : top1 / bottom, intercept : top2 / bottom});\n\t\t}\n\t}\n\treturn result;\n};\nhsluv.Hsluv.maxSafeChromaForL = function(L) {\n\tvar bounds = hsluv.Hsluv.getBounds(L);\n\tvar min = 1.7976931348623157e+308;\n\tvar _g = 0;\n\twhile(_g < 2) {\n\t\tvar i = _g++;\n\t\tvar length = hsluv.Geometry.distanceLineFromOrigin(bounds[i]);\n\t\tmin = Math.min(min,length);\n\t}\n\treturn min;\n};\nhsluv.Hsluv.maxChromaForLH = function(L,H) {\n\tvar hrad = H / 360 * Math.PI * 2;\n\tvar bounds = hsluv.Hsluv.getBounds(L);\n\tvar min = 1.7976931348623157e+308;\n\tvar _g = 0;\n\twhile(_g < bounds.length) {\n\t\tvar bound = bounds[_g];\n\t\t++_g;\n\t\tvar length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad,bound);\n\t\tif(length >= 0) min = Math.min(min,length);\n\t}\n\treturn min;\n};\nhsluv.Hsluv.dotProduct = function(a,b) {\n\tvar sum = 0;\n\tvar _g1 = 0;\n\tvar _g = a.length;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tsum += a[i] * b[i];\n\t}\n\treturn sum;\n};\nhsluv.Hsluv.fromLinear = function(c) {\n\tif(c <= 0.0031308) return 12.92 * c; else return 1.055 * Math.pow(c,0.416666666666666685) - 0.055;\n};\nhsluv.Hsluv.toLinear = function(c) {\n\tif(c > 0.04045) return Math.pow((c + 0.055) / 1.055,2.4); else return c / 12.92;\n};\nhsluv.Hsluv.xyzToRgb = function(tuple) {\n\treturn [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2],tuple))];\n};\nhsluv.Hsluv.rgbToXyz = function(tuple) {\n\tvar rgbl = [hsluv.Hsluv.toLinear(tuple[0]),hsluv.Hsluv.toLinear(tuple[1]),hsluv.Hsluv.toLinear(tuple[2])];\n\treturn [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2],rgbl)];\n};\nhsluv.Hsluv.yToL = function(Y) {\n\tif(Y <= hsluv.Hsluv.epsilon) return Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa; else return 116 * Math.pow(Y / hsluv.Hsluv.refY,0.333333333333333315) - 16;\n};\nhsluv.Hsluv.lToY = function(L) {\n\tif(L <= 8) return hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa; else return hsluv.Hsluv.refY * Math.pow((L + 16) / 116,3);\n};\nhsluv.Hsluv.xyzToLuv = function(tuple) {\n\tvar X = tuple[0];\n\tvar Y = tuple[1];\n\tvar Z = tuple[2];\n\tvar divider = X + 15 * Y + 3 * Z;\n\tvar varU = 4 * X;\n\tvar varV = 9 * Y;\n\tif(divider != 0) {\n\t\tvarU /= divider;\n\t\tvarV /= divider;\n\t} else {\n\t\tvarU = NaN;\n\t\tvarV = NaN;\n\t}\n\tvar L = hsluv.Hsluv.yToL(Y);\n\tif(L == 0) return [0,0,0];\n\tvar U = 13 * L * (varU - hsluv.Hsluv.refU);\n\tvar V = 13 * L * (varV - hsluv.Hsluv.refV);\n\treturn [L,U,V];\n};\nhsluv.Hsluv.luvToXyz = function(tuple) {\n\tvar L = tuple[0];\n\tvar U = tuple[1];\n\tvar V = tuple[2];\n\tif(L == 0) return [0,0,0];\n\tvar varU = U / (13 * L) + hsluv.Hsluv.refU;\n\tvar varV = V / (13 * L) + hsluv.Hsluv.refV;\n\tvar Y = hsluv.Hsluv.lToY(L);\n\tvar X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);\n\tvar Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);\n\treturn [X,Y,Z];\n};\nhsluv.Hsluv.luvToLch = function(tuple) {\n\tvar L = tuple[0];\n\tvar U = tuple[1];\n\tvar V = tuple[2];\n\tvar C = Math.sqrt(U * U + V * V);\n\tvar H;\n\tif(C < 0.00000001) H = 0; else {\n\t\tvar Hrad = Math.atan2(V,U);\n\t\tH = Hrad * 180.0 / 3.1415926535897932;\n\t\tif(H < 0) H = 360 + H;\n\t}\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToLuv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tvar Hrad = H / 360.0 * 2 * Math.PI;\n\tvar U = Math.cos(Hrad) * C;\n\tvar V = Math.sin(Hrad) * C;\n\treturn [L,U,V];\n};\nhsluv.Hsluv.hsluvToLch = function(tuple) {\n\tvar H = tuple[0];\n\tvar S = tuple[1];\n\tvar L = tuple[2];\n\tif(L > 99.9999999) return [100,0,H];\n\tif(L < 0.00000001) return [0,0,H];\n\tvar max = hsluv.Hsluv.maxChromaForLH(L,H);\n\tvar C = max / 100 * S;\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToHsluv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tif(L > 99.9999999) return [H,0,100];\n\tif(L < 0.00000001) return [H,0,0];\n\tvar max = hsluv.Hsluv.maxChromaForLH(L,H);\n\tvar S = C / max * 100;\n\treturn [H,S,L];\n};\nhsluv.Hsluv.hpluvToLch = function(tuple) {\n\tvar H = tuple[0];\n\tvar S = tuple[1];\n\tvar L = tuple[2];\n\tif(L > 99.9999999) return [100,0,H];\n\tif(L < 0.00000001) return [0,0,H];\n\tvar max = hsluv.Hsluv.maxSafeChromaForL(L);\n\tvar C = max / 100 * S;\n\treturn [L,C,H];\n};\nhsluv.Hsluv.lchToHpluv = function(tuple) {\n\tvar L = tuple[0];\n\tvar C = tuple[1];\n\tvar H = tuple[2];\n\tif(L > 99.9999999) return [H,0,100];\n\tif(L < 0.00000001) return [H,0,0];\n\tvar max = hsluv.Hsluv.maxSafeChromaForL(L);\n\tvar S = C / max * 100;\n\treturn [H,S,L];\n};\nhsluv.Hsluv.rgbToHex = function(tuple) {\n\tvar h = \"#\";\n\tvar _g1 = 0;\n\tvar _g = tuple.length;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tvar chan = tuple[i];\n\t\th += StringTools.hex(Math.round(chan * 255),2).toLowerCase();\n\t}\n\treturn h;\n};\nhsluv.Hsluv.hexToRgb = function(hex) {\n\thex = hex.toUpperCase();\n\treturn [Std.parseInt(\"0x\" + HxOverrides.substr(hex,1,2)) / 255.0,Std.parseInt(\"0x\" + HxOverrides.substr(hex,3,2)) / 255.0,Std.parseInt(\"0x\" + HxOverrides.substr(hex,5,2)) / 255.0];\n};\nhsluv.Hsluv.lchToRgb = function(tuple) {\n\treturn hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));\n};\nhsluv.Hsluv.rgbToLch = function(tuple) {\n\treturn hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));\n};\nhsluv.Hsluv.hsluvToRgb = function(tuple) {\n\treturn hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));\n};\nhsluv.Hsluv.rgbToHsluv = function(tuple) {\n\treturn hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));\n};\nhsluv.Hsluv.hpluvToRgb = function(tuple) {\n\treturn hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));\n};\nhsluv.Hsluv.rgbToHpluv = function(tuple) {\n\treturn hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));\n};\nhsluv.Hsluv.hsluvToHex = function(tuple) {\n\treturn hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));\n};\nhsluv.Hsluv.hpluvToHex = function(tuple) {\n\treturn hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));\n};\nhsluv.Hsluv.hexToHsluv = function(s) {\n\treturn hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));\n};\nhsluv.Hsluv.hexToHpluv = function(s) {\n\treturn hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));\n};\nhsluv.Hsluv.m = [[3.240969941904521,-1.537383177570093,-0.498610760293],[-0.96924363628087,1.87596750150772,0.041555057407175],[0.055630079696993,-0.20397695888897,1.056971514242878]];\nhsluv.Hsluv.minv = [[0.41239079926595,0.35758433938387,0.18048078840183],[0.21263900587151,0.71516867876775,0.072192315360733],[0.019330818715591,0.11919477979462,0.95053215224966]];\nhsluv.Hsluv.refY = 1.0;\nhsluv.Hsluv.refU = 0.19783000664283;\nhsluv.Hsluv.refV = 0.46831999493879;\nhsluv.Hsluv.kappa = 903.2962962;\nhsluv.Hsluv.epsilon = 0.0088564516;\nvar root = {\n    \"hsluvToRgb\": hsluv.Hsluv.hsluvToRgb,\n    \"rgbToHsluv\": hsluv.Hsluv.rgbToHsluv,\n    \"hpluvToRgb\": hsluv.Hsluv.hpluvToRgb,\n    \"rgbToHpluv\": hsluv.Hsluv.rgbToHpluv,\n    \"hsluvToHex\": hsluv.Hsluv.hsluvToHex,\n    \"hexToHsluv\": hsluv.Hsluv.hexToHsluv,\n    \"hpluvToHex\": hsluv.Hsluv.hpluvToHex,\n    \"hexToHpluv\": hsluv.Hsluv.hexToHpluv\n};// CommonJS module system (including Node)\nif (typeof module !== 'undefined') {\n    module['exports'] = root;\n}\n\n// AMD module system\nif (typeof define !== 'undefined') {\n    define(root);\n}\n\n// Export to browser\nif (typeof window !== 'undefined') {\n    window['hsluv'] = root;\n}\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/hsluv/hsluv.js\n// module id = 6\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;;;;;;AC7DA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AAUA;AACA;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AANA;AAQA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpHA;AACA;;;;;AACA;;;;;;;;;;;;;ACFA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}